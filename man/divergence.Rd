% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_group_measures.R
\name{divergence}
\alias{divergence}
\title{Divergence Index}
\source{
Created by Elizabeth Roberto: \url{https://arxiv.org/abs/1508.01167}
}
\usage{
divergence(
  ...,
  weights = "sum",
  na.rm = TRUE,
  summed = FALSE,
  sumPercent = "weights",
  rowTotals = NA
)
}
\arguments{
\item{...}{Population vectors for every group included in the divergence
calculation.}

\item{weights}{Either a vector of weights summing to one, or the total
population for each observation in \code{...}. Can be any of:
\describe{
\item{A numeric vector}{The length of each vector provided in each
entry in \code{...} (i.e. the column-wise length of \code{...}). Can be either population
or weights by observation}
\item{\code{sum}}{Sets \code{weights} to the rowwise sum of \code{...}}
\item{\code{none}}{Weighs each observation evenly (1/length). Note that if \code{...} is a
set of percentages summing to 1 for each row, \code{sum} and \code{none} are equivalent.}
}}

\item{na.rm}{logical. Should missing values (including NaN) be removed?
Used only if \code{summed} is set to TRUE.}

\item{summed}{If TRUE, will return a single summary statistic. (Or one value per group if specifying
\code{dplyr::group_by}.) If FALSE (default), will return a vector equaling the length
of the input vectors. If 'weighted' (only for divergence and information theory), returns
a vector as in FALSE, but with pre-weighted values,
such that \verb{sum(divergence(..., summed = 'weighted))} is equivalent to
\code{divergence(..., summed = T)}.}

\item{sumPercent}{The percentage of each group in the larger population (i.e. the
population composed of the sum of groups provided in \code{...}). Can be any of:
\describe{
\item{A numeric vector}{Each entry represents the total population of the  with one entry for each group/vector provided in \code{...}. (i.e.
the rowwise length of \code{...}).
Note that for this to work correctly, each group must be provided in the same order in
\code{sumPercent} as in \code{...} Useful if the sum of \code{sumPercent} is less than 100\%, as \code{divergence}
will otherwise force}
\item{\code{weights}}{Default. Uses the value of \code{weights} to construct total population proportions.
If weights is set to \code{none}, the total population proportions will be the unweighted
average of the percentages in each observation.}
}}

\item{rowTotals}{By default, the rowwise sum of \code{...} is treated as 100\% of the population.
Setting this parameter to any of the following options changes this behavior.
\describe{
\item{\code{NA}}{Default. Forces the rowwise sum of \code{...} to equal 100\% of the
population. Works with either percentages or population totals.}
\item{\verb{100\%}}{Uses 1 (100\%) as the row total. For this to
work properly, each column provided to \code{...} must be percentages, not
population totals. Useful if the rowwise sum of percentages is less than 100\%; only use if
you know what you are doing.}
\item{\code{weights}}{Uses the "weights" parameter as the total population.}
\item{A numeric vector}{With length equal to each vector provided in each
entry in \code{...} (i.e. the column-wise length of \code{...}). }
}}
}
\value{
A single value if summed==TRUE, or a vector equaling the length of the inputs.
}
\description{
Elizabeth Roberto's Divergence index for calculating and decomposing segregation.
}
\examples{
library(rsegregation)
data("bay_race")
#return by-observation scores
divergence(bay_race$white,bay_race$hispanic,bay_race$asian,
bay_race$black, bay_race$all_other)

# Using dplyr
require(dplyr)
mutate(bay_race, divergence_score = divergence(white, hispanic,
  asian, black, all_other))

# divergence alsow works with percentages as long as you have
# population totals by observation
bay_race \%>\%
  mutate_at(vars(hispanic:all_other), list(~(./total_pop))) \%>\%
  mutate(divergence_score = divergence(white, hispanic, asian,
  black, all_other, weights = total_pop))

}
